/* 
 * Square Connect API
 *
 * Client library for accessing the Square Connect APIs
 *
 * OpenAPI spec version: 2.0
 * Contact: developers@squareup.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;

namespace Square.Connect.Model
{
    /// <summary>
    /// Defines how prices are modified or set for items that match the pricing rule during the active time period.
    /// </summary>
    [DataContract]
    public partial class CatalogPricingRule :  IEquatable<CatalogPricingRule>, IValidatableObject
    {
        /// <summary>
        /// Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values
        /// </summary>
        /// <value>Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum StackableEnum
        {
            
            /// <summary>
            /// Enum UNKNOWN for "UNKNOWN"
            /// </summary>
            [EnumMember(Value = "UNKNOWN")]
            UNKNOWN,
            
            /// <summary>
            /// Enum BASE for "BASE"
            /// </summary>
            [EnumMember(Value = "BASE")]
            BASE,
            
            /// <summary>
            /// Enum STACKABLE for "STACKABLE"
            /// </summary>
            [EnumMember(Value = "STACKABLE")]
            STACKABLE,
            
            /// <summary>
            /// Enum EXCLUSIVE for "EXCLUSIVE"
            /// </summary>
            [EnumMember(Value = "EXCLUSIVE")]
            EXCLUSIVE
        }

        /// <summary>
        /// Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values
        /// </summary>
        /// <value>Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values</value>
        [DataMember(Name="stackable", EmitDefaultValue=false)]
        public StackableEnum? Stackable { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CatalogPricingRule" /> class.
        /// </summary>
        /// <param name="Name">User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;..</param>
        /// <param name="TimePeriodIds">Unique ID for the [CatalogTimePeriod](#type-catalogtimeperiod)s when this pricing rule is in effect. If left unset, the pricing rule is always in effect..</param>
        /// <param name="TotalPriceMoney">The total amount of money to charge for all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied..</param>
        /// <param name="ItemPriceMoney">The amount of money to charge for each matched item.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied..</param>
        /// <param name="DiscountId">Unique ID for the [CatalogDiscount](#type-catalogdiscount) to take off the price of all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied..</param>
        /// <param name="MatchProductsId">Unique ID for the [CatalogProductSet](#type-catalogproductset) that will be matched by this rule. A match rule matches within the entire cart..</param>
        /// <param name="ApplyProductsId">The [CatalogProductSet](#type-catalogproductset) to apply the pricing rule to within the set of matched products specified by &#x60;match_products_id&#x60;. An apply rule can only match once within the set of matched products. If left unset, the pricing rule will be applied to all products within the set of matched products..</param>
        /// <param name="Stackable">Describes how the pricing rule can be combined with other pricing rules. See [Stackable](#type-stackable) for all possible values. See [AggregationStrategy](#type-aggregationstrategy) for possible values.</param>
        /// <param name="ExcludeProductsId">Identifies the [CatalogProductSet](#type-catalogproductset) to exclude from this pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules..</param>
        /// <param name="ValidFromDate">Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD)..</param>
        /// <param name="ValidFromLocalTime">Represents the local time the pricing rule should be valid from. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated..</param>
        /// <param name="ValidUntilDate">Represents the date the pricing rule will become inactive.  Represented in RFC3339 full-date format (YYYY-MM-DD)..</param>
        /// <param name="ValidUntilLocalTime">Represents the local time at which the pricing rule will become inactive. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated..</param>
        public CatalogPricingRule(string Name = default(string), List<string> TimePeriodIds = default(List<string>), Money TotalPriceMoney = default(Money), Money ItemPriceMoney = default(Money), string DiscountId = default(string), string MatchProductsId = default(string), string ApplyProductsId = default(string), StackableEnum? Stackable = default(StackableEnum?), string ExcludeProductsId = default(string), string ValidFromDate = default(string), string ValidFromLocalTime = default(string), string ValidUntilDate = default(string), string ValidUntilLocalTime = default(string))
        {
            this.Name = Name;
            this.TimePeriodIds = TimePeriodIds;
            this.TotalPriceMoney = TotalPriceMoney;
            this.ItemPriceMoney = ItemPriceMoney;
            this.DiscountId = DiscountId;
            this.MatchProductsId = MatchProductsId;
            this.ApplyProductsId = ApplyProductsId;
            this.Stackable = Stackable;
            this.ExcludeProductsId = ExcludeProductsId;
            this.ValidFromDate = ValidFromDate;
            this.ValidFromLocalTime = ValidFromLocalTime;
            this.ValidUntilDate = ValidUntilDate;
            this.ValidUntilLocalTime = ValidUntilLocalTime;
        }
        
        /// <summary>
        /// User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;.
        /// </summary>
        /// <value>User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }
        /// <summary>
        /// Unique ID for the [CatalogTimePeriod](#type-catalogtimeperiod)s when this pricing rule is in effect. If left unset, the pricing rule is always in effect.
        /// </summary>
        /// <value>Unique ID for the [CatalogTimePeriod](#type-catalogtimeperiod)s when this pricing rule is in effect. If left unset, the pricing rule is always in effect.</value>
        [DataMember(Name="time_period_ids", EmitDefaultValue=false)]
        public List<string> TimePeriodIds { get; set; }
        /// <summary>
        /// The total amount of money to charge for all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.
        /// </summary>
        /// <value>The total amount of money to charge for all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.</value>
        [DataMember(Name="total_price_money", EmitDefaultValue=false)]
        public Money TotalPriceMoney { get; set; }
        /// <summary>
        /// The amount of money to charge for each matched item.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.
        /// </summary>
        /// <value>The amount of money to charge for each matched item.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.</value>
        [DataMember(Name="item_price_money", EmitDefaultValue=false)]
        public Money ItemPriceMoney { get; set; }
        /// <summary>
        /// Unique ID for the [CatalogDiscount](#type-catalogdiscount) to take off the price of all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.
        /// </summary>
        /// <value>Unique ID for the [CatalogDiscount](#type-catalogdiscount) to take off the price of all matched items.  Only one of &#x60;total_price_money&#x60;, &#x60;item_price&#x60;, or &#x60;discount&#x60; can be supplied.</value>
        [DataMember(Name="discount_id", EmitDefaultValue=false)]
        public string DiscountId { get; set; }
        /// <summary>
        /// Unique ID for the [CatalogProductSet](#type-catalogproductset) that will be matched by this rule. A match rule matches within the entire cart.
        /// </summary>
        /// <value>Unique ID for the [CatalogProductSet](#type-catalogproductset) that will be matched by this rule. A match rule matches within the entire cart.</value>
        [DataMember(Name="match_products_id", EmitDefaultValue=false)]
        public string MatchProductsId { get; set; }
        /// <summary>
        /// The [CatalogProductSet](#type-catalogproductset) to apply the pricing rule to within the set of matched products specified by &#x60;match_products_id&#x60;. An apply rule can only match once within the set of matched products. If left unset, the pricing rule will be applied to all products within the set of matched products.
        /// </summary>
        /// <value>The [CatalogProductSet](#type-catalogproductset) to apply the pricing rule to within the set of matched products specified by &#x60;match_products_id&#x60;. An apply rule can only match once within the set of matched products. If left unset, the pricing rule will be applied to all products within the set of matched products.</value>
        [DataMember(Name="apply_products_id", EmitDefaultValue=false)]
        public string ApplyProductsId { get; set; }
        /// <summary>
        /// Identifies the [CatalogProductSet](#type-catalogproductset) to exclude from this pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
        /// </summary>
        /// <value>Identifies the [CatalogProductSet](#type-catalogproductset) to exclude from this pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.</value>
        [DataMember(Name="exclude_products_id", EmitDefaultValue=false)]
        public string ExcludeProductsId { get; set; }
        /// <summary>
        /// Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
        /// </summary>
        /// <value>Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).</value>
        [DataMember(Name="valid_from_date", EmitDefaultValue=false)]
        public string ValidFromDate { get; set; }
        /// <summary>
        /// Represents the local time the pricing rule should be valid from. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
        /// </summary>
        /// <value>Represents the local time the pricing rule should be valid from. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.</value>
        [DataMember(Name="valid_from_local_time", EmitDefaultValue=false)]
        public string ValidFromLocalTime { get; set; }
        /// <summary>
        /// Represents the date the pricing rule will become inactive.  Represented in RFC3339 full-date format (YYYY-MM-DD).
        /// </summary>
        /// <value>Represents the date the pricing rule will become inactive.  Represented in RFC3339 full-date format (YYYY-MM-DD).</value>
        [DataMember(Name="valid_until_date", EmitDefaultValue=false)]
        public string ValidUntilDate { get; set; }
        /// <summary>
        /// Represents the local time at which the pricing rule will become inactive. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
        /// </summary>
        /// <value>Represents the local time at which the pricing rule will become inactive. Time zone is determined by the device running the Point of Sale app.  Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.</value>
        [DataMember(Name="valid_until_local_time", EmitDefaultValue=false)]
        public string ValidUntilLocalTime { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CatalogPricingRule {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  TimePeriodIds: ").Append(TimePeriodIds).Append("\n");
            sb.Append("  TotalPriceMoney: ").Append(TotalPriceMoney).Append("\n");
            sb.Append("  ItemPriceMoney: ").Append(ItemPriceMoney).Append("\n");
            sb.Append("  DiscountId: ").Append(DiscountId).Append("\n");
            sb.Append("  MatchProductsId: ").Append(MatchProductsId).Append("\n");
            sb.Append("  ApplyProductsId: ").Append(ApplyProductsId).Append("\n");
            sb.Append("  Stackable: ").Append(Stackable).Append("\n");
            sb.Append("  ExcludeProductsId: ").Append(ExcludeProductsId).Append("\n");
            sb.Append("  ValidFromDate: ").Append(ValidFromDate).Append("\n");
            sb.Append("  ValidFromLocalTime: ").Append(ValidFromLocalTime).Append("\n");
            sb.Append("  ValidUntilDate: ").Append(ValidUntilDate).Append("\n");
            sb.Append("  ValidUntilLocalTime: ").Append(ValidUntilLocalTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as CatalogPricingRule);
        }

        /// <summary>
        /// Returns true if CatalogPricingRule instances are equal
        /// </summary>
        /// <param name="other">Instance of CatalogPricingRule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CatalogPricingRule other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Name == other.Name ||
                    this.Name != null &&
                    this.Name.Equals(other.Name)
                ) && 
                (
                    this.TimePeriodIds == other.TimePeriodIds ||
                    this.TimePeriodIds != null &&
                    this.TimePeriodIds.SequenceEqual(other.TimePeriodIds)
                ) && 
                (
                    this.TotalPriceMoney == other.TotalPriceMoney ||
                    this.TotalPriceMoney != null &&
                    this.TotalPriceMoney.Equals(other.TotalPriceMoney)
                ) && 
                (
                    this.ItemPriceMoney == other.ItemPriceMoney ||
                    this.ItemPriceMoney != null &&
                    this.ItemPriceMoney.Equals(other.ItemPriceMoney)
                ) && 
                (
                    this.DiscountId == other.DiscountId ||
                    this.DiscountId != null &&
                    this.DiscountId.Equals(other.DiscountId)
                ) && 
                (
                    this.MatchProductsId == other.MatchProductsId ||
                    this.MatchProductsId != null &&
                    this.MatchProductsId.Equals(other.MatchProductsId)
                ) && 
                (
                    this.ApplyProductsId == other.ApplyProductsId ||
                    this.ApplyProductsId != null &&
                    this.ApplyProductsId.Equals(other.ApplyProductsId)
                ) && 
                (
                    this.Stackable == other.Stackable ||
                    this.Stackable != null &&
                    this.Stackable.Equals(other.Stackable)
                ) && 
                (
                    this.ExcludeProductsId == other.ExcludeProductsId ||
                    this.ExcludeProductsId != null &&
                    this.ExcludeProductsId.Equals(other.ExcludeProductsId)
                ) && 
                (
                    this.ValidFromDate == other.ValidFromDate ||
                    this.ValidFromDate != null &&
                    this.ValidFromDate.Equals(other.ValidFromDate)
                ) && 
                (
                    this.ValidFromLocalTime == other.ValidFromLocalTime ||
                    this.ValidFromLocalTime != null &&
                    this.ValidFromLocalTime.Equals(other.ValidFromLocalTime)
                ) && 
                (
                    this.ValidUntilDate == other.ValidUntilDate ||
                    this.ValidUntilDate != null &&
                    this.ValidUntilDate.Equals(other.ValidUntilDate)
                ) && 
                (
                    this.ValidUntilLocalTime == other.ValidUntilLocalTime ||
                    this.ValidUntilLocalTime != null &&
                    this.ValidUntilLocalTime.Equals(other.ValidUntilLocalTime)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Name != null)
                    hash = hash * 59 + this.Name.GetHashCode();
                if (this.TimePeriodIds != null)
                    hash = hash * 59 + this.TimePeriodIds.GetHashCode();
                if (this.TotalPriceMoney != null)
                    hash = hash * 59 + this.TotalPriceMoney.GetHashCode();
                if (this.ItemPriceMoney != null)
                    hash = hash * 59 + this.ItemPriceMoney.GetHashCode();
                if (this.DiscountId != null)
                    hash = hash * 59 + this.DiscountId.GetHashCode();
                if (this.MatchProductsId != null)
                    hash = hash * 59 + this.MatchProductsId.GetHashCode();
                if (this.ApplyProductsId != null)
                    hash = hash * 59 + this.ApplyProductsId.GetHashCode();
                if (this.Stackable != null)
                    hash = hash * 59 + this.Stackable.GetHashCode();
                if (this.ExcludeProductsId != null)
                    hash = hash * 59 + this.ExcludeProductsId.GetHashCode();
                if (this.ValidFromDate != null)
                    hash = hash * 59 + this.ValidFromDate.GetHashCode();
                if (this.ValidFromLocalTime != null)
                    hash = hash * 59 + this.ValidFromLocalTime.GetHashCode();
                if (this.ValidUntilDate != null)
                    hash = hash * 59 + this.ValidUntilDate.GetHashCode();
                if (this.ValidUntilLocalTime != null)
                    hash = hash * 59 + this.ValidUntilLocalTime.GetHashCode();
                return hash;
            }
        }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        { 
            yield break;
        }
    }

}
